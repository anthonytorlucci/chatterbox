"""

"""
# standard lib
from pathlib import Path
# third party
import pytest
# langchain
# from langchain_core.messages.ai import AIMessage
# from langchain_community.document_loaders import PyMuPDFLoader
# from langchain_ollama import OllamaEmbeddings
# from langchain_chroma import Chroma
# from langchain_text_splitters import RecursiveCharacterTextSplitter
# langgraph
# local
from chatterbox.nodes.pdf_context_retriever import PdfContextRetriever

PDF_FILE_PATH = Path(__file__).parent.joinpath("3490443.pdf")

@pytest.fixture
def pdf_retriever():
    """Fixture to create a basic ArxivContextRetriever instance."""
    return PdfContextRetriever(
        pdf_paths=[PDF_FILE_PATH],
        chunk_size=200,
        chunk_overlap=50,
        k_results=2
    )

class TestArxivContextRetriever:

    def test_initialization(self):
        """Test if the PdfContextRetriever initializes with correct parameters."""
        retriever = PdfContextRetriever(
            pdf_paths=[PDF_FILE_PATH],
            chunk_size=300,
            chunk_overlap=75,
            k_results=2
        )

        assert retriever._vector_store_is_valid == True
        assert retriever._k_results == 2

    # def test_empty_initialization(self):
    #     """Test if the PdfContextRetreiver initializes with empty pdf paths."""
    #     retriever = PdfContextRetriever(
    #         pdf_paths=[],
    #         chunk_size=300,
    #         chunk_overlap=75,
    #         k_results=2
    #     )

    #     assert retriever._vector_store_is_valid == False


# generated by phi4
# Initialization Tests
# def test_init_valid_pdf_paths():
#     # Arrange
#     pdf_paths = [Path("path/to/pdf1.pdf"), Path("path/to/pdf2.pdf")]
#     chunk_size = 400
#     chunk_overlap = 100
#     k_results = 3

#     # Act
#     retriever = PdfContextRetriever(pdf_paths, chunk_size, chunk_overlap, k_results)

#     # Assert
#     assert retriever._vector_store_is_valid is True
#     assert isinstance(retriever._embeddings, OllamaEmbeddings)
#     assert isinstance(retriever._vector_store, Chroma)

# def test_init_invalid_pdf_paths():
#     # Arrange
#     pdf_paths = [Path("path/to/non_existent_pdf.pdf")]

#     # Act and Assert
#     with pytest.raises(ValueError):
#         PdfContextRetriever(pdf_paths, chunk_size=400, chunk_overlap=100, k_results=3)

# Document Processing Tests
# def test_process_documents():
#     # Arrange
#     pdf_paths = [Path("path/to/pdf1.pdf"), Path("path/to/pdf2.pdf")]
#     chunk_size = 400
#     chunk_overlap = 100
#     k_results = 3

#     retriever = PdfContextRetriever(pdf_paths, chunk_size, chunk_overlap, k_results)

#     # Act
#     documents = retriever._vector_store.get_documents()

#     # Assert
#     assert len(documents) > 0
#     for document in documents:
#         assert isinstance(document, dict)

# Vector Store Setup Tests
# def test_setup_vector_store():
#     # Arrange
#     pdf_paths = [Path("path/to/pdf1.pdf"), Path("path/to/pdf2.pdf")]
#     chunk_size = 400
#     chunk_overlap = 100
#     k_results = 3

#     retriever = PdfContextRetriever(pdf_paths, chunk_size, chunk_overlap, k_results)

#     # Act
#     retriever._vector_store.add_documents(documents=[{"id": "1", "content": "doc1"}])

#     # Assert
#     assert retriever._vector_store.get_documents() == [{"id": "1", "content": "doc1"}]

# Retrieval Tests
# def test_retrieve_by_vector():
#     # Arrange
#     pdf_paths = [Path("path/to/pdf1.pdf"), Path("path/to/pdf2.pdf")]
#     chunk_size = 400
#     chunk_overlap = 100
#     k_results = 3

#     retriever = PdfContextRetriever(pdf_paths, chunk_size, chunk_overlap, k_results)

#     # Act
#     results = retriever._vector_store.similarity_search_by_vector(embedding="query", k=k_results)

#     # Assert
#     assert len(results) > 0
#     for result in results:
#         assert isinstance(result, dict)

#
